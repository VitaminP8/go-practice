### Планировщик Go

Планировщик Go — это ключевой компонент языка, который управляет выполнением горутин (легковесных потоков) на доступных ядрах процессора. Он спроектирован для эффективного использования ресурсов и обеспечения высокой производительности в конкурентных программах. Давайте разберем основные аспекты планировщика Go.

---

### 1. **Зачем Go собственный планировщик?**

Go использует собственный планировщик, чтобы эффективно управлять тысячами или даже миллионами горутин. Вот основные причины:

- **Легковесность горутин**:
    - Горутины намного легче, чем потоки ОС (например, в Linux поток занимает минимум 1 МБ стека, а горутина — несколько КБ).
    - Планировщик Go оптимизирован для работы с большим количеством горутин.

- **Эффективное использование процессора**:
    - Планировщик Go распределяет горутины по ядрам процессора, минимизируя накладные расходы на переключение контекста.

- **Интеграция с runtime**:
    - Планировщик тесно интегрирован с runtime Go, что позволяет эффективно управлять памятью, сборкой мусора и системными вызовами.

---

### 2. **Проектируем планировщик: отдельные очереди**

Планировщик Go использует **локальные очереди** для каждого потока (M), чтобы минимизировать конкуренцию за доступ к данным:

- **Локальные очереди**:
    - Каждый поток (M) имеет свою локальную очередь горутин (G).
    - Это уменьшает contention (конкуренцию) за доступ к данным, так как большинство операций выполняется локально.

- **Преимущества**:
    - Уменьшение накладных расходов на синхронизацию.
    - Улучшение производительности за счет локальности данных.

---

### 3. **Проектируем планировщик: work stealing**

Work stealing — это механизм, который позволяет потокам "воровать" задачи у других потоков, если их локальные очереди пусты:

- **Как это работает**:
    - Если у потока (M) нет задач в локальной очереди, он пытается "украсть" задачи из локальных очередей других потоков.
    - Если и там задач нет, поток обращается к **глобальной очереди**.

- **Преимущества**:
    - Балансировка нагрузки между потоками.
    - Эффективное использование ресурсов процессора.

---

### 4. **Проектируем планировщик: syscall**

Системные вызовы (syscall) могут блокировать выполнение горутин. Планировщик Go обрабатывает это следующим образом:

- **Блокирующие syscall**:
    - Если горутина выполняет блокирующий системный вызов, поток (M) отвязывается от горутины и может выполнять другие задачи.
    - После завершения syscall горутина возвращается в очередь для выполнения.

- **Неблокирующие syscall**:
    - Если syscall не блокирует выполнение, горутина продолжает выполняться на текущем потоке.

---

### 5. **Проектируем планировщик: глобальная очередь**

Глобальная очередь — это общая очередь задач, которая используется, когда локальные очереди пусты:

- **Назначение**:
    - Хранение задач, которые не могут быть выполнены локально.
    - Используется как резервный источник задач для потоков.

- **Недостатки**:
    - Доступ к глобальной очереди требует синхронизации, что может быть дорогостоящим.

---

### 6. **Планировщик: честность, trade-off (FIFO, 1 element LIFO buffer)**

Планировщик Go использует компромиссы между честностью и производительностью:

- **FIFO (First In, First Out)**:
    - Горутины выполняются в порядке их добавления в очередь.
    - Обеспечивает честность, но может быть менее эффективным.

- **1 element LIFO buffer**:
    - Последняя добавленная горутина может выполняться первой. (имеет ограничение, на случай если горутины постоянно порождают новые горутины)
    - Улучшает производительность за счет локальности данных, но может быть менее честным.

---

### 7. **Планировщик: порядок поиска работы**

Планировщик Go использует следующий порядок поиска задач:

1. **Локальная очередь**:
    - Поток сначала проверяет свою локальную очередь.

2. **Глобальная очередь**:
    - Если локальная очередь пуста, поток обращается к глобальной очереди.

3. **Work stealing**:
    - Если глобальная очередь пуста, поток пытается "украсть" задачи у других потоков.

---

### 8. **Планировщик: network poller**

Network poller — это компонент планировщика, который отвечает за асинхронные операции ввода-вывода (I/O):

- **Как это работает**:
    - Когда горутина выполняет операцию I/O (например, чтение из сети), она блокируется.
    - Network poller отслеживает состояние операций I/O и уведомляет планировщик, когда операция завершена.
    - Горутина возвращается в очередь для выполнения.

- **Преимущества**:
    - Эффективное использование ресурсов процессора.
    - Уменьшение накладных расходов на блокирующие операции I/O.

---

### Итог

Планировщик Go — это сложная и высокооптимизированная система, которая обеспечивает эффективное выполнение горутин на многопроцессорных системах. Он использует:

- Локальные очереди для минимизации contention.
- Work stealing для балансировки нагрузки.
- Глобальную очередь как резервный источник задач.
- Network poller для асинхронного I/O.
- Компромиссы между честностью и производительностью.
