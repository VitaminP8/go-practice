# Конфигурация в Go

## О чём стоит задуматься при проектировании конфигурации

### 1. Где и как хранить конфигурацию?
- Варианты: файлы, переменные окружения, ключ-значение хранилища (etcd, Vault), параметры командной строки.
- Что коммитим в репозиторий, а что держим вне (например, секреты)?

### 2. Кто будет работать с конфигурацией?
- Разработчики, DevOps, заказчик, конечный пользователь?
- Нужен ли им доступ к конфигурации, и если да — в каком виде?

### 3. Как часто и нужно ли менять конфигурацию на ходу?
- Статическая или динамическая конфигурация?
- Нужен ли hot reload?

### 4. Типизация и валидация
- Лучше использовать типы Go (`int`, `bool`, `time.Duration`), чем строки.
- Нужна ли валидация обязательных параметров?

### 5. Разные окружения (dev/staging/prod)
- Есть ли различия между ними?
- Как переключаться между конфигурациями для разных сред?

---

## Основные концепции

### 1. Конфигурация — отделение переменных от кода
- **Проблема**: Поведение приложения часто зависит от среды (например, dev/prod).
- **Решение**: Все, что может меняться между окружениями, выносится в конфигурацию: файлы, переменные окружения, параметры запуска и т.д.

### 2. Типизация и инкапсуляция
- Создавайте отдельный пакет `config`, чтобы изолировать логику работы с конфигурацией.
- Используйте Go-структуры с аннотациями (`yaml`, `envconfig`, `mapstructure` и др.) и типизированные поля (например, `int`, `time.Duration`).

---

## Источники конфигурации

### 1. Файлы конфигурации
- YAML/JSON/TOML и др.
- Пример:
```go
type Config struct {
    Domain    string   `yaml:"domain"`
    Blacklist []string `yaml:"blacklist"`
}

data, _ := ioutil.ReadFile("config.yaml")
yaml.Unmarshal(data, &cfg)
```

```yaml
domain: example.com
blacklist:
  - spam.com
  - bot.net
```

### 2. Переменные окружения
- Удобны для CI/CD и секретов (например, токенов).
- Не коммитятся в репозиторий.
- Пример (ручное считывание):
```go
port, _ := strconv.Atoi(os.Getenv("MYAPP_PORT"))
host := os.Getenv("MYAPP_HOST")
```

---


## Библиотеки для конфигурации

### 1. [`envconfig`](https://github.com/kelseyhightower/envconfig)
- Маппит переменные окружения в структуру.
```go
type Config struct {
    Port     int    `default:"8080"`
    ApiToken string `required:"true"`
}
envconfig.Process("myapp", &cfg)
```

---

### 2. [`viper`](https://github.com/spf13/viper)

Одна из самых популярных и мощных библиотек для работы с конфигурацией в Go. Поддерживает:

- Чтение из файлов (JSON, TOML, YAML, HCL, INI).
- Переменные окружения.
- Флаги командной строки.
- Значения по умолчанию.
- Динамическое обновление (hot reload).
- Несколько конфигурационных файлов и путей.

---

#### Приоритет источников конфигурации (от более высокого к низкому):
1. **Прямое указание через `viper.Set()`**.
2. **Флаги командной строки** (если связаны через `viper.BindPFlag`).
3. **Переменные окружения** (`viper.BindEnv`).
4. **Файл конфигурации** (`viper.ReadInConfig`).
5. **Удалённые хранилища** (например, etcd, Consul — через плагины).
6. **Значения по умолчанию** (`viper.SetDefault`).

---

#### Пример использования:
```go
type Config struct {
    Host string
    Port int
}

func LoadConfig() (*Config, error) {
    viper.SetConfigName("config")      // имя файла без расширения
    viper.SetConfigType("yaml")        // тип файла
    viper.AddConfigPath(".")           // путь для поиска
    viper.AddConfigPath("/etc/myapp")  // можно добавить другие пути

    viper.SetDefault("port", 8080)
    viper.BindEnv("host", "MYAPP_HOST") // переменная окружения

    if err := viper.ReadInConfig(); err != nil {
        return nil, fmt.Errorf("read config: %w", err)
    }

    return &Config{
        Host: viper.GetString("host"),
        Port: viper.GetInt("port"),
    }, nil
}
```


#### Пример файла `config.yaml`:
```yaml
host: localhost
port: 9090
```



#### Особенности:
- Названия параметров автоматически преобразуются в snake_case при привязке к переменным окружения.
- Можно отслеживать изменения в файле:
```go
viper.WatchConfig()
viper.OnConfigChange(func(e fsnotify.Event) {
    fmt.Println("Config file changed:", e.Name)
})
```

- Для интеграции с флагами `pflag` (из `spf13/cobra`) используется `viper.BindPFlag`.

---

### 3. [`confita`](https://github.com/heetch/confita)
- Позволяет комбинировать источники: env, файлы, vault и др.
```go
loader := confita.NewLoader(env.NewBackend(), file.NewBackend("config.yaml"))
loader.Load(context.Background(), &cfg)
```

---

## Практические советы

- Создавайте пакет `config`, чтобы изолировать логику загрузки.
- Используйте структуры с валидными типами (int, bool, duration).
- Разделяйте логику загрузки и использования параметров.
- Не тяните значения из env/файлов в бизнес-логику напрямую.

---

## Итог
- Конфигурация делает код гибким и переиспользуемым.
- В Go удобно использовать как встроенные инструменты (`os.Getenv`), так и библиотеки (`envconfig`, `viper`, `confita`).
- Храните секреты в переменных окружения.
- Используйте типизированные структуры и отдельные пакеты.
