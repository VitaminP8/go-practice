# `atomic` в Go: Атомарные операции

**`atomic`** — это пакет в Go, который предоставляет низкоуровневые атомарные операции для синхронизации доступа к общим данным. Атомарные операции гарантируют, что операции чтения и записи выполняются без вмешательства других горутин, что делает их полезными для реализации простых и эффективных примитивов синхронизации.

---

## Основное использование

Пакет `atomic` предоставляет функции для работы с атомарными типами, такими как `int32`, `int64`, `uint32`, `uint64`, `uintptr` и указатели.

### Основные функции:
1. **`AddT(addr *T, delta T)`**:
    - Атомарно добавляет `delta` к значению по адресу `addr`.
2. **`LoadT(addr *T) T`**:
    - Атомарно загружает значение по адресу `addr`.
3. **`StoreT(addr *T, val T)`**:
    - Атомарно сохраняет `val` по адресу `addr`.
4. **`SwapT(addr *T, new T) T`**:
    - Атомарно заменяет значение по адресу `addr` на `new` и возвращает старое значение.
5. **`CompareAndSwapT(addr *T, old, new T) bool`**:
    - Атомарно сравнивает значение по адресу `addr` с `old` и, если они равны, заменяет его на `new`. Возвращает `true`, если замена произошла.

---

### Пример использования

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var counter int32
	var wg sync.WaitGroup

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			atomic.AddInt32(&counter, 1)
		}()
	}

	wg.Wait()
	fmt.Println("Counter:", atomic.LoadInt32(&counter)) // Output: Counter: 100
}
```

---

## Как это работает?

1. **Атомарные операции**:
    - Атомарные операции выполняются за один шаг, что делает их безопасными для использования в многопоточной среде.

2. **Сравнение и замена**:
    - `CompareAndSwap` (CAS) — это мощная операция, которая позволяет реализовать сложные примитивы синхронизации, такие как спинлоки.

3. **Эффективность**:
    - Атомарные операции обычно быстрее, чем использование мьютексов, так как они работают на уровне процессора.

---

## Особенности

1. **Ограниченные типы**:
    - Атомарные операции поддерживают только определенные типы, такие как `int32`, `int64`, `uint32`, `uint64`, `uintptr` и указатели.

2. **Низкоуровневый API**:
    - `atomic` предоставляет низкоуровневый API, который требует осторожного использования.

3. **Использование для простых сценариев**:
    - Атомарные операции идеально подходят для простых сценариев, таких как счетчики или флаги.


---

## Когда использовать `atomic`, а когда `sync.Mutex`?

### Использовать `atomic`, если:
1. **Простая синхронизация**:
    - Вы работаете с простыми типами данных, такими как счетчики (`int32`, `int64`) или флаги (`bool`).
    - Пример: атомарный инкремент счетчика.

2. **Высокая производительность**:
    - Вам нужно минимизировать накладные расходы на синхронизацию, особенно в сценариях с высокой конкуренцией.
    - Пример: реализация спинлоков.

3. **Короткие критические секции**:
    - Операции, которые нужно синхронизировать, выполняются быстро, и блокировка на короткое время допустима.
    - Пример: обновление флага состояния.

### Использовать `sync.Mutex`, если:
1. **Сложные структуры данных**:
    - Вы работаете с более сложными структурами данных, такими как `map`, `slice` или пользовательские структуры.
    - Пример: защита доступа к map.

2. **Длительные критические секции**:
    - Операции, которые нужно синхронизировать, выполняются долго, и блокировка на длительное время допустима.
    - Пример: выполнение сложных вычислений или операций ввода-вывода.

3. **Удобство и читаемость**:
    - Вам нужно реализовать сложную логику синхронизации, и `sync.Mutex` делает код более понятным и поддерживаемым.
    - Пример: защита доступа к нескольким связанным переменным.

---

## Заключение

- **`atomic`** — это мощный инструмент для реализации атомарных операций в многопоточной среде.
- Используйте `Add`, `Load`, `Store`, `Swap` и `CompareAndSwap` для работы с атомарными типами.
- Атомарные операции идеально подходят для простых сценариев, таких как счетчики, флаги и спинлоки. (тк они медленнее чем обычные операции и атомарность распространяется только на 1 операцию (не стоит делать группу зависимых атомарных операций))

