# `sync.RWMutex` в Go: Чтение и запись с синхронизацией

**`sync.RWMutex`** — это примитив синхронизации в Go, который позволяет нескольким горутинам одновременно читать данные, но блокирует запись, пока хотя бы одна горутина читает. Это делает `RWMutex` более эффективным, чем `sync.Mutex`, в сценариях с частыми операциями чтения.

---

## Основное использование

`sync.RWMutex` имеет четыре основных метода:
1. **`Lock()`**:
    - Блокирует мьютекс для записи. Если мьютекс уже заблокирован для чтения или записи, горутина будет ждать, пока он не освободится.
2. **`Unlock()`**:
    - Разблокирует мьютекс для записи.
3. **`RLock()`**:
    - Блокирует мьютекс для чтения. Если мьютекс заблокирован для записи, горутина будет ждать, пока он не освободится.
4. **`RUnlock()`**:
    - Разблокирует мьютекс для чтения.

---

### Пример использования

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type SafeMap struct {
	mu   sync.RWMutex
	data map[string]string
}

func (sm *SafeMap) Set(key, value string) {
	sm.mu.Lock()         // Блокируем для записи
	defer sm.mu.Unlock() // Разблокируем при выходе
	sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (string, bool) {
	sm.mu.RLock()         // Блокируем для чтения
	defer sm.mu.RUnlock() // Разблокируем при выходе
	value, exists := sm.data[key]
	return value, exists
}

func main() {
	sm := SafeMap{data: make(map[string]string)}
	var wg sync.WaitGroup

	// Горутина для записи
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ {
			sm.Set(fmt.Sprintf("key%d", i), fmt.Sprintf("value%d", i))
			time.Sleep(100 * time.Millisecond)
		}
	}()

	// Горутины для чтения
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for j := 0; j < 5; j++ {
				key := fmt.Sprintf("key%d", j)
				value, _ := sm.Get(key)
				fmt.Printf("Goroutine %d: %s = %s\n", id, key, value)
				time.Sleep(100 * time.Millisecond)
			}
		}(i)
	}

	wg.Wait()
}
```

#### Вывод:
```
Goroutine 0: key0 = value0
Goroutine 1: key0 = value0
Goroutine 2: key0 = value0
Goroutine 0: key1 = value1
Goroutine 1: key1 = value1
Goroutine 2: key1 = value1
...
```

---

## Как это работает?

1. **Блокировка для записи**:
    - Когда горутина вызывает `Lock()`, она получает эксклюзивный доступ для записи.
    - Если мьютекс уже заблокирован для чтения или записи, горутина будет ждать, пока он не освободится.

2. **Блокировка для чтения**:
    - Когда горутина вызывает `RLock()`, она получает доступ для чтения.
    - Если мьютекс заблокирован для записи, горутина будет ждать, пока он не освободится.

3. **Разблокировка**:
    - `Unlock()` разблокирует мьютекс для записи.
    - `RUnlock()` разблокирует мьютекс для чтения.

4. **Использование `defer`**:
    - Рекомендуется использовать `defer` для вызова `Unlock()` и `RUnlock()`, чтобы гарантировать, что мьютекс будет разблокирован даже в случае паники.

---

## Особенности

1. **Множественное чтение**:
    - Несколько горутин могут одновременно читать данные, если мьютекс не заблокирован для записи.

2. **Эксклюзивная запись**:
    - Только одна горутина может писать данные в любой момент времени.

3. **Производительность**:
    - `RWMutex` более эффективен, чем `Mutex`, в сценариях с частыми операциями чтения.

    

---

## Заключение

- **`sync.RWMutex`** — это мощный инструмент для синхронизации доступа к данным в многопоточной среде.
- Используйте `Lock()` и `Unlock()` для эксклюзивной записи.
- Используйте `RLock()` и `RUnlock()` для множественного чтения.
- Всегда используйте `defer` для вызова `Unlock()` и `RUnlock()`, чтобы избежать deadlock.
